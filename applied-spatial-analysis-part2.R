## applied-spatial-analysis-part2.R

## Chapter 7 - Spatial Point Pattern Analysis

## 7.1 Introduction

## POINT PROCESS:
## A point process is a stochastic process in which we observe the locations
## of some events of interest within a bounded region; a stochastic mechanism
## which generates a countable set of events.

## POINT PATTERN:
## The locations of points generated by a point process in the area of study A
## will be called a point pattern.


library(spatstat)
data(japanesepines)
summary(japanesepines)
class(japanesepines)

library(maptools) ## convert between ppp objects & SpatialPoints
spjpines <- as(japanesepines, "SpatialPoints")
summary(spjpines) ## use actual units
class(spjpines)

spjpines1 <- elide(spjpines, scale=TRUE, unitsq=TRUE) ## cnvrt to unit square
summary(spjpines1)
class(spjpines1)

## can also coerce back to ppp
pppjap <- as(spjpines1, "ppp")
summary(pppjap)

## in spatial epidemiology it is common to have two types of points: cases of
## a certain disease and controls which reflect the spatial distribution of 
## the population. Called marked point pattern because each point is assigned
## to a group (labelled).

## ASTHMA STUDY
## Explore relationship between asthma prevalence and proximity to main roads
## and three polution sources.


library(rgdal)
spasthma <- readOGR("ch7/.", "spasthma") ## ASTHMA CASES
spbdry <- readOGR("ch7/.", "spbdry") ## BOUNDARY OF AREA
spsrc <- readOGR("ch7/.", "spsrc") ## POLLUTION SOURCE
sproads <- readOGR("ch7/.", "sproads") ## ROADS IN AREA


plot(spbdry, axes=TRUE, lwd=0.5)
plot(sproads, add=TRUE, lwd=2, col="darkslategrey")

## cases = 2; controls = 1
c_c <- (spasthma$Asthma == "case") + 1
plot(spasthma[c_c == 1,], add=TRUE, pch=4, cex=0.6, col="mediumaquamarine")
plot(spasthma[c_c == 2,], add=TRUE, pch=17, cex=0.75, col="goldenrod2")
plot(spsrc, pch=22, add=TRUE, cex=1.2, bg="brown4")
legend("topright", legend=c("controls", "cases", "pollution sources"), pch=c(4, 17, 22), pt.cex=c(0.6, 0.75, 1.2), pt.bg=c(NA, NA, "brown4"), col=c("mediumaquamarine", "goldenrod2", "black"), bty="n") 


## when studying a point process, the most basic test that cen be performed
## is that of Complete Spatial Randomness (CSR) - events are distributed
## independently at random and uniformly over the study area. This implies
## that there are no regions where the events are more/less likely to occur
## and that the presence of a given event does not modify the probability of
## an event happening elsewhere.

data(redwoodfull)
spred <- as(redwoodfull, "SpatialPoints")
data(cells)
spcells <- as(cells, "SpatialPoints")
dpp<-data.frame(rbind(coordinates(spjpines1), coordinates(spred), 
                      coordinates(spcells)))
njap<-nrow(coordinates(spjpines1))
nred<-nrow(coordinates(spred))
ncells<-nrow(coordinates(spcells))
dpp<-cbind(dpp,c(rep("JAPANESE",njap), rep("REDWOOD", nred), rep("CELLS", ncells))) 
names(dpp)<-c("x", "y", "DATASET")

library(lattice)
print(xyplot(y~x|DATASET, data=dpp, pch=19, aspect=1))
## CELLS - regular, uniform pattern
## JAPANESE - neither regular, nor clustered
## REDWOOD - clustered


## 7.3.2 G Function: Distance to the Nearest Event
## The G function measures the distribution of the distances from an arbitrary
## event to its nearest event. The compatibility with CSR of the point
## pattern can be assessed by plotting the empirical function G-hat 
## against the theoretical distribution G. Point-wise envelopes under
## CSR can be computed by repeatedly simulating a CSR point process with 
## the same estimated intensity lambda in the study region and check
## whether the empirical function is contained inside.


## do 99 simulations of CSR for each type setting 96% CI
set.seed(120109)
r <- seq(0, sqrt(2)/6, by = 0.005)
envjap <- envelope(as(spjpines1, "ppp"), fun = Gest, r = r, nrank = 2, nsim=99)
envred <- envelope(as(spred, "ppp"), fun = Gest, r = r, nrank = 2, nsim = 99)
envcells <- envelope(as(spcells, "ppp"), fun=Gest, r=r, nrank=2, nsim=99)
Gresults <- rbind(envjap, envred, envcells) 
Gresults <- cbind(Gresults, 
                  y=rep(c("JAPANESE", "REDWOOD", "CELLS"), each=length(r)))

print(xyplot(obs~theo|y , data=Gresults, type="l", 
             xlab = "theoretical", ylab = "observed", 
             panel=function(x, y, subscripts) {
               lpolygon(c(x, rev(x)), 
                        c(Gresults$lo[subscripts], rev(Gresults$hi[subscripts])),
                        border="gray", col="gray"
               )
               llines(x, y, col="black", lwd=2)
             }))
## CELLS - regular, uniform pattern (G-hat below envelope)
## JAPANESE - homogenously distributed (G-hat within envelope)
## REDWOOD - clustered distribution (G-hat above envelope)

## Envelope is a flexible function that can be used to compute
## monet-carlo envelops of certain types of functions. It works
## by randomly simulating a number of point patterns so that the
## summary function is computed for all of them. Resulting values
## are used to compute point-wise (at diff distances) or monte carlo
## envelopes.

## 7.3.3 F Function: Distance from a Point to the Nearest Event
## The F function measures the distribution of all distances from an
## arbitrary point of the plane to its nearest event. Also called the
## empty space function b/c it is a measure of the average space left
## between events.

set.seed(30)

## re-compute r b/c error:
## Error: in Fest(X, r) the successive r values must be finely spaced: 
## given spacing = 0.005; required spacing <=  0.00195
r <- seq(0, sqrt(2)/6, by = 0.001)

Fenvjap<-envelope(as(spjpines1, "ppp"), fun=Fest, r=r, nrank=2, nsim=99)
Fenvred<-envelope(as(spred, "ppp"), fun=Fest, r=r, nrank=2, nsim=99)
Fenvcells<-envelope(as(spcells, "ppp"), fun=Fest, r=r, nrank=2, nsim=99)
Fresults<-rbind(Fenvjap, Fenvred, Fenvcells)
Fresults<-cbind(Fresults, 
                y=rep(c("JAPANESE", "REDWOOD", "CELLS"), each=length(r)))

print(xyplot(obs~theo|y , data=Fresults, type="l", 
             xlab = "theoretical", ylab = "observed", 
             panel=function(x, y, subscripts) {
               lpolygon(c(x, rev(x)), 
                        c(Fresults$lo[subscripts], rev(Fresults$hi[subscripts])),
                        border="gray", col="gray"
               )
               llines(x, y, col="black", lwd=2)
             }))
## JAPANESE data are compatible with the CSR hypothesis
## CELLS show regular pattern (G-hat above env)
## REDWOOD show clustering (G-hat below env)

## 7.4 Statistical Analysis of Spatial Point Processes
## estimate the spatial statistical density from observed data
## we can work with the intensity of the point process which is
## proportional to its spatial density.
## The constant of proportionality is the expected number of events
## of the point process in area A. For two point processes w same
## spatial density but different intensities, the number of events
## observed will be higher for the process with highest density.

## First-order properties measure the distribution of events in the study region
## Second-order properties reflect tendency of events to appear
## clustered, independent, or regularly spaced.

## we can distinguish two types of poisson processes: homogenous (HPP)
## and inhomogenous (IPP). Both assume events occur independently and
## are distributed according to a given intensity. HPP assumes intensity
## is constant; in IPP intensity varies spatially.

## 7.4.1 Homogenous Poisson Processes
## HPP - all events are independent and uniformly distributed in region
## where the point process occurs. Location of one point does not effect
## the probability of other points occuring nearby and that there are no regions
## where events are more likely to occur.

## 7.4.2 Inhomogenous Poisson Processes
## IPP is generalization of HPP, which allows for non-constant intensity.
## Independence of events still holds, but events can appear more likely
## in some areas than others.

library("splancs")
mserwq<-mse2d(as.points(coordinates(spred)),
              as.points(list(x=c(0,1,1,0), y=c(0,0,1,1))), 100, .15)
bwq<-mserwq$h[which.min(mserwq$mse)]
bwq

#Spatstat code

mserw<-bw.diggle(as(spred, "ppp"))
bw<-as.numeric(mserw)
bw


## kernel smoothing using quartic kernel
library(splancs)
poly <- as.points(list(x = c(0, 0, 1, 1), y = c(0, 1, 1, 0)))
sG <- Sobj_SpatialGrid(spred, maxDim=100)$SG
grd <- slot(sG, "grid")
summary(grd)
k0 <- spkernel2d(spred, poly, h0=bw, grd)
k1 <- spkernel2d(spred, poly, h0=.05, grd)
k2 <- spkernel2d(spred, poly, h0=.1, grd)
k3 <- spkernel2d(spred, poly, h0=.15, grd)
df <- data.frame(k0=k0, k1=k1, k2=k2, k3=k3) 
kernels <- SpatialGridDataFrame(grd, data=df)
summary(kernels)

## kernel smoothing using isotropic Gaussian kernel
cc <- coordinates(kernels)
xy<-list(x=cc[,1], y=cc[,2])
k4<-density(as(spred, "ppp"), .5*bw, dimyx=c(100, 100), xy=xy)
kernels$k4<-as(k4, "SpatialGridDataFrame")$v
k5<-density(as(spred, "ppp"), .5*.05, dimyx=c(100, 100), xy=xy)
kernels$k5<-as(k5, "SpatialGridDataFrame")$v
k6<-density(as(spred, "ppp"), .5*.1, dimyx=c(100, 100), xy=xy)
kernels$k6<-as(k6, "SpatialGridDataFrame")$v
k7<-density(as(spred, "ppp"), .5*.15, dimyx=c(100, 100), xy=xy)
kernels$k7<-as(k7, "SpatialGridDataFrame")$v
summary(kernels)

library(RColorBrewer)
gp <- brewer.pal(8, "Reds")
print(spplot(kernels, at=c(0, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000), col.regions=colorRampPalette(gp)(15)[1:12], 
             names.attr=c(paste("Q bw=",round(bw, digits=4), sep="", collapse=""),
                          "Q bw=0.05", "Q bw=0.1","Q bw=0.15", paste("G bw=", round(.5*bw, digits=4),
                                                                     sep="", collapse=""), "G bw=0.025", "G bw=0.05","G bw=0.075"), cex=0.7, colorkey=FALSE))

#Fit parametric model
loglambda<-function(x, alpha, beta)
{
  l<-alpha+sum(beta*c(x, x*x, prod(x)))
  return(l)
}

L<-function(alphabeta, x)
{
  l<-apply(x,1,loglambda, alpha=alphabeta[1], beta=alphabeta[-1])
  l<-sum(l)
  intL<-adaptIntegrate(lowerLimit=c(0,0), upperLimit=c(1,1), fDim=1,
                       tol=1e-8, f=function(x, alpha=alphabeta[1], beta=alphabeta[-1])
                       {
                         exp(loglambda(x, alpha, beta))
                       })
  l<-l-intL$integral
  return(l)#Optim minimises
}

## location of maple trees Lansing Woods - fit parametric intensity
library("cubature")
data(lansing)
x<-as.points(lansing[lansing$marks=="maple",])
#Maximise log-likelihood
optbeta<-optim(par=c(log(514),0,0,0,0,0), fn=L, control=list(maxit=1000, fnscale=-1), x=x)

grd <- GridTopology(cellcentre.offset=c(0.005,0.005), cellsize=c(0.01, 0.01),
                    cells.dim=c(100, 100))
lambda<-exp(apply(coordinates(grd),1, function(X, alpha, beta)
{
  loglambda(X, alpha, beta)
}, alpha=optbeta$par[1], beta=optbeta$par[-1]
))

parint<-SpatialGridDataFrame(grd, data=data.frame(intensity=lambda))

lyt<-list("sp.points", SpatialPoints(x), pch=19, col="black", cex=0.7)
print(spplot(parint, at=seq(0,1400,length.out=8),
             col.regions=colorRampPalette(gp)(7), sp.layout=list(lyt)))

lmaple<-lansing[lansing$marks=="maple",]
ppm(Q=lmaple, trend=~x+y+I(x^2)+I(y^2)+I(x*y))


## 7.4.5 Second-order Properties
## Second-order properties measure the strenth and type of the interactions
## between events of the point process -- useful for studying clustering
## or competition between events. Second-order intensity of two points x & y
## reflects the probability of any pair of events occurring in the vicinities
## of x & y respectively.
## The K-function measures the number of events found up to a given distance
## of any particular event.

set.seed(30)
Kenvjap<-envelope(as(spjpines1, "ppp"), fun=Kest, r=r, nrank=2, nsim=99)
Kenvred<-envelope(as(spred, "ppp"), fun=Kest, r=r, nrank=2, nsim=99)
Kenvcells<-envelope(as(spcells, "ppp"), fun=Kest, r=r, nrank=2, nsim=99)
Kresults<-rbind(Kenvjap, Kenvred, Kenvcells)
Kresults<-cbind(Kresults, 
                y=rep(c("JAPANESE", "REDWOOD", "CELLS"), each=length(r)))

print(xyplot((obs-theo)~r|y , data=Kresults, type="l",
             ylim= c(-.06, .06), ylab=expression(hat(K) (r)  - pi * r^2),
             panel=function(x, y, subscripts) {
               Ktheo<- Kresults$theo[subscripts]
               lpolygon(c(r, rev(r)),
                        c(Kresults$lo[subscripts]-Ktheo, rev(Kresults$hi[subscripts]-Ktheo)),
                        border="gray", col="gray"
               )
               llines(r, Kresults$obs[subscripts]-Ktheo, lty=2, lwd=1.5, col="black")
             }))

## 7.5 Some Applications in Spatial Epidemiology
## Distribution of the cases of a certain disease can be regarded as the
## realization of a point process which reflects the underlying distribution
## of the population (which is usually *not* homogenous) plus any other
## risk factors related to the disease and that are likely to depend on
## the subjects.

## 7.5.1 Case-Control Studies
## estimator of the disease risk given by the ratio between the intensity
## of the cases and controls in order to assess the variation of the risk. 
## Under the null hypothesis of equal spatial distribution the ratio is constant

bwasthma<-.06

pppasthma<-as(spasthma, "ppp")
pppasthma$window<-as(spbdry, "owin")

marks(pppasthma)<-relevel(pppasthma$marks$Asthma, "control")
cases<-unmark(subset(pppasthma, marks(pppasthma) =="case"))
ncases<-npoints(cases)
controls<-unmark(subset(pppasthma, marks(pppasthma) =="control"))
ncontrols<-npoints(controls)

kcases<-density(cases, bwasthma)
kcontrols<-density(controls, bwasthma)
class(kcases) ## <- "im" object (Pixel Image Object)

spkratio0<-as(kcases, "SpatialGridDataFrame")
names(spkratio0)<-"kcases"
spkratio0$kcontrols<-as(kcontrols, "SpatialGridDataFrame")$v
spkratio<-as(spkratio0, "SpatialPixelsDataFrame")

spkratio$kratio <- spkratio$kcases/spkratio$kcontrols
spkratio$logratio <- log(spkratio$kratio)-log(ncases/ncontrols)

niter <- 99
ratio <- rep(NA, niter)
pvaluemap <- rep(0, nrow(spkratio))
rlabelratio <- matrix(NA, nrow=niter, ncol=nrow(spkratio))

set.seed(1)
for(i in 1:niter)
{
  pppasthma0<-rlabel(pppasthma)
  casesrel <- unmark(subset(pppasthma0, marks(pppasthma0) =="case"))
  controlsrel <- unmark(subset(pppasthma0, marks(pppasthma0) =="control"))
  
  kcasesrel <- density(casesrel, bwasthma)
  kcontrolsrel <- density(controlsrel, bwasthma)
  kratiorel <- eval.im(kcasesrel/kcontrolsrel)
  rlabelratio[i,] <- as(as(kratiorel, "SpatialGridDataFrame"), "SpatialPixelsDataFrame")$v
  pvaluemap <- pvaluemap + (spkratio$kratio < rlabelratio[i,])
}

cellsize<-kcontrols$xstep*kcontrols$ystep
ratiorho <- cellsize*sum((spkratio$kratio-ncases/ncontrols)^2)
ratio <- cellsize*apply(rlabelratio, 1, 
                        function(X, rho0 ){sum((X-rho0)^2)}, rho0=ncases/ncontrols
)
pvaluerho <- (sum(ratio > ratiorho)+1)/(niter+1)

spkratio$pvaluemap <- (pvaluemap+1)/(niter+1)
imgpvalue <- as.image.SpatialGridDataFrame(spkratio["pvaluemap"])
clpvalue <- contourLines(imgpvalue, levels=c(0,.05, .95, 1))
cl <- ContourLines2SLDF(clpvalue)

library(RColorBrewer)
cl05 <- cl[cl$level == "0.05",]
xzx <- slot(slot(cl05, "lines")[[1]], "Lines")
cl05a <- SpatialLines(list(Lines(xzx, ID="0.05")))
lyt05 <- list("sp.lines", cl05a, lwd=2, lty=2, col="grey95")
lyt95 <- list("sp.lines", cl[cl$level == "0.95",], lwd=2, lty=1)
lytb <- list("sp.polygons", spbdry)
lytp <- list("sp.points", spsrc, cex=0.9, pch=4, col="grey95", lwd=3)
brks <- quantile(spkratio$kratio[spkratio$kratio>0], seq(0,1,1/10), na.rm=TRUE)
brks[1] <- 0
lbrks <- formatC(brks, 3, 6, "g", " ")
cols <- colorRampPalette(brewer.pal(7, "Reds"))(length(brks)-1)
colorkey<-list(labels=lbrks,
               at=(0:10)/10, height=.5)

print(spplot(spkratio, "kratio",
             col.regions=cols,
             do.log=TRUE, 
             colorkey=colorkey,
             at=c(0, brks[-c(1,11)], max(spkratio$kratio, na.rm=TRUE)),
             sp.layout=list(lyt05, lyt95, lytb, lytp) 
))


## 7.5.2 Binary Regression Estimator
## Estimate the prob of being a case at a given location

rrbw <- bw.relrisk(pppasthma, hmax = 0.5)
bwasthmap <- 0.06
rr <- relrisk(pppasthma, bwasthmap)
spkratio$prob <- as(as(rr,"SpatialGridDataFrame"),"SpatialPixelsDataFrame")$v


## 7.5.3 Binary Regression Using Generalized Additive Models
## fit a GAM using the distance of the events to the pollution sources
## and main roads and controlling for known and possible risk factors
## such as gender, age, previous events of hayfever, and having at least
## one smoke in the house.

spasthma$y <- as.integer(!as.integer(spasthma$Asthma)-1)
ccasthma <- coordinates(spasthma)
spasthma$x1 <- ccasthma[,1]
spasthma$x2 <- ccasthma[,2]
spasthma$dist1 <- sqrt(spasthma$d2source1)
spasthma$dist2 <- sqrt(spasthma$d2source2)
spasthma$dist3 <- sqrt(spasthma$d2source3)
spasthma$droads <- sqrt(spasthma$roaddist2)
spasthma$smoking <- as.factor(as.numeric(spasthma$Nsmokers>0))
spasthma$Genderf<- as.factor(spasthma$Gender)
spasthma$HayFeverf<- as.factor(spasthma$HayFever)
library(mgcv)
gasthma<-gam(y~1+dist1+dist2+dist3+droads+Genderf+Age+HayFeverf+smoking+s(x1,x2), data=spasthma[spasthma$Gender==1 | spasthma$Gender==2, ], family=binomial)
summary(gasthma)

## 7.5.4 Point Source Pollution

D2_mat <- as.matrix(spasthma$dist2)
RHO <- ncases/ncontrols
expsource2<-tribble(ccflag=spasthma$y, vars=D2_mat, rho=RHO, alphas=1, betas=1)
print(expsource2)

#Hay fever
Hay_mat <- as.matrix(spasthma$HayFever)
exphay <- tribble(ccflag=spasthma$y, rho=RHO, covars=Hay_mat, thetas=1)
print(exphay)

## 7.5.4.1 Assessment of General Spatial Clustering
## Spatial varition occurs when the risk is not homorgenous in the study region
## (i.e. all individuals do not have the same risk) but cases appear
## independently of each other according to this risk surface, whilst
## clustering occurs when the occurence of cases is not random and the presence
## of a case increases the probabilty of other cases occuring nearby.

Kdif<-function(Xppp, r, cr="border")
{
  k1<-Kest(Xppp[marks(Xppp)=="case"], r=r, correction=cr)
  k2<-Kest(Xppp[marks(Xppp)=="control"], r=r, correction=cr)
  
  res<-data.frame(r=r, D=k1[[cr]]-k2[[cr]])
  return(fv(res, valu="D", fname="D"))
}

r<-seq(0, .15, by=.01)

envKdif<-envelope(pppasthma, Kdif, r=r, nsim=99, cr="iso",  nrank=2,
                  savefuns=TRUE,
                  simulate=expression(rlabel(pppasthma)))
khcases<-Kest(cases, r=r, correction="isotropic")
khcontrols<-Kest(controls, r=r, correction="isotropic")


## 7.5.5 Accounting for Confounding & Covariates
glmasthma<-glm(y~HayFeverf, data=spasthma, family="binomial")
prob<-fitted(glmasthma)
weights<-exp(glmasthma$linear.predictors)
lambda0<-  interp.im (kcontrols, coords(cases)[,1], coords(cases)[,2])
lambda1<- weights[marks(pppasthma) =="case"]*lambda0

ratiocc<-ncases/ncontrols
kihnocov<-Kinhom(cases, ratiocc*lambda0, r=r)
kih<-Kinhom(cases, lambda1, r=r)

## 8.2 Exploratory Data Analysis
require(RColorBrewer)
require(lattice)
pal = function(n = 9) brewer.pal(n, "Reds")
library(sp)
data(meuse)
coordinates(meuse) <- c("x", "y")

print(xyplot(log(zinc)~sqrt(dist), as.data.frame(meuse), asp = .8), split = 
        c(1, 1,2,1), more = TRUE)
zn.lm <- lm(log(zinc)~sqrt(dist), meuse)
meuse$fitted.s <- predict(zn.lm, meuse) - mean(predict(zn.lm, meuse))
meuse$residuals <- residuals(zn.lm)
print(spplot(meuse, c("fitted.s", "residuals"), col.regions = 
               pal(), cuts = 8, colorkey=TRUE), split = c(2,1,2,1))

## 8.3 Non-geostatistical Interpolation Methods
data(meuse.grid)
coordinates(meuse.grid) <- c("x", "y")
meuse.grid <- as(meuse.grid, "SpatialPixelsDataFrame")

## 8.3.1 Inverse Distance Weighted Interpolation
## Inverse distance power determines the degree to which the nearer points
## are preferred over more distant points; for large values IDW converges
## to the one-nearest-neighbor interpolation.

